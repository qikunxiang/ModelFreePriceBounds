function [rprice_ub, rprice_lb, weight_opt, output]...
    = lsipaccpalgo_gurobi(port, price_bounds, repl, ...
    weight_fixed, options)
% Accelerated central cutting plane algorithm that computes the robust 
% upper bound of the price of a portfolio.
% Inputs:
%       port: the portfolio returned by function portcreate
%       price_bounds: the upper and lower bounds of known derivatives, if
%           only one column is supplied, there will not be bid-ask spread
%       repl: logical vector specifying the portfolio to be
%           super-replicated
%       weight_fixed: vector of weights in the portfolio to be
%           super-replicated
%       options: structure containing options
%           tol: positive tolerance
%           init_x: (optional) initial set of x, each column is one set of
%               x
%           init_rprice_lb: initial lower bound of the robust price
%           init_rprice_ub: initial upper bound of the robust price
%           radius_factor: a factor for scaling radius
%           cut_lb_factor: a factor for adjusting cut w.r.t. lower bound
%           milp_gap: the relative gap tolerance used when solving MILP
%           display: whether to display Gurobi output
% Outputs:
%       rprice_ub: upper bound on the robust price of the portfolio
%       rprice_lb: lower bound on the robust price of the portfolio
%       weight_vec: complete weight vector of the non-negative portfolio
%       output: structure containing additional output:
%           iter: number of iterations
%           lp_count: number of LP solved
%           milp_count: number of MILP solved
%           x: all feasibility cuts

if ~isfield(options, 'tol')
    options.tol = 1e-3;
end

if ~isfield(options, 'radius_factor')
    options.radius_factor = 0.1;
end

if ~isfield(options, 'cut_lb_factor')
    options.cut_lb_factor = 0.5;
end

if ~isfield(options, 'milp_gap')
    options.milp_gap = 0.8;
end

if ~isfield(options, 'display')
    options.display = true;
end

% whether bid-ask spread is considered
has_spread = length(price_bounds) > port.m;

n = port.n;

if has_spread
    coef_num = sum(~repl) * 2 - 1;
else
    coef_num = sum(~repl);
end

coef_ub = 100;

% constraints related to upper and lower bounds on weights
if has_spread
    A_bounds = [speye(coef_num); -speye(coef_num)];
    b_bounds = [coef_ub * ones(coef_num, 1); coef_ub; ...
        zeros(coef_num - 1, 1)];
else
    A_bounds = [speye(coef_num); -speye(coef_num)];
    b_bounds = coef_ub * ones(2 * coef_num, 1);
end

% constraints generated by feasibility cuts
A_feas = sparse(0, coef_num);
b_feas = zeros(0, 1);
x_agg = zeros(n, 0);

% list of active constraints
active_list = true(0, 1);

% constraints that are marked as undeletable
marked_list = false(0, 1);

% list of radii
radii = [];

% new constraints generated in the previous iteration, whose radii need to
% be updated
newcons_prev_iter = [];

% if the initial cuts are specified
if isfield(options, 'init_x')
    cons_C_x = portpointcons(port, options.init_x);
    [newcons_C_x, newb_x] = replportcons(cons_C_x, repl, weight_fixed, ...
        has_spread);
    A_feas =  -newcons_C_x;
    b_feas = newb_x;
    x_agg = options.init_x;
    init_cons_num = length(b_feas);
    active_list = true(init_cons_num, 1);
    marked_list = false(init_cons_num, 1);
    radii = inf(init_cons_num, 1);
    newcons_prev_iter = 1:init_cons_num;
end

% constraint generated by objective cut
A_obj = sparse(price_bounds');
rprice_ub = options.init_rprice_ub;

% initial lower bound
rprice_lb = options.init_rprice_lb;

% start iteration
iter = 0;
lp_count = 0;
milp_count = 0;
weight_opt = [];
rad = inf;
state_switch = false;
radii_check_list = [];
x_opt = [];
measure_opt = [];
dual_opt = [];

while rprice_ub - rprice_lb > options.tol
    fprintf(['iteration %4d: current radius: %.6f, ', ...
        'current UB: %.6f, current LB: %.6f\n'], ...
        iter, rad, rprice_ub, rprice_lb);
    
    % current objective cut
    if ~state_switch
        rprice_cut = (rprice_ub + rprice_lb) / 2;
    else
        rprice_cut = rprice_lb + (1 - options.cut_lb_factor) ...
            * (rprice_cut - rprice_lb);
    end
    
    poly_A = [A_bounds; A_feas(active_list, :); A_obj];
    poly_b = [b_bounds; b_feas(active_list); rprice_cut];
    
    [w, rad] = polytopecenterempty_gurobi(poly_A, poly_b, options.display);
    lp_count = lp_count + 1;
    radii_check_list = [radii_check_list; rad]; %#ok<AGROW>
    radii_max2_list = max(radii_check_list(1:end - 1), ...
        radii_check_list(2:end));
    
    if ~all(radii_max2_list(2:end) <= radii_max2_list(1:end - 1) + 1e-2)
        warning('Something is wrong, the radii pattern is invalid');
    end
    
    if isempty(w)
        % the polytope is empty
        rad = -1;
        state_switch = false;
        
        % aggregate all feasibility cuts to get a lower bound on the robust
        % price
        lb_model = struct;
        lb_model.obj = price_bounds;
        lb_model.A = [A_bounds; A_feas(active_list, :)];
        lb_model.rhs = [b_bounds; b_feas(active_list)];
        lb_params = struct;
        lb_params.Method = 2;
        lb_params.Crossover = 0;
        lb_params.FeasibilityTol = 1e-6;
        lb_params.OptimalityTol = 1e-5;
        
        if options.display
            lb_params.OutputFlag = 1;
        else
            lb_params.OutputFlag = 0;
        end
        
        lb_output = gurobi(lb_model, lb_params);
        lp_count = lp_count + 1;
        lb_obj = lb_output.objval;
        
        if ~strcmp(lb_output.status, 'OPTIMAL')
            lb_obj = -inf;
        end
        
        % make the update a bit conservative to prevent the inaccuracy in
        % the LP solution from plaging the correctness of the algorithm
        rprice_lb = max(rprice_cut, lb_obj - 2 * options.tol);
        
        if all(abs(lb_output.pi(1:2 * coef_num)) < 1e-9)
            measure_opt = -lb_output.pi(2 * coef_num + 1:end);
            x_opt = x_agg(:, active_list);
            x_opt(x_opt < 0) = 0;
            x_opt = round(x_opt, 4);
            dual_opt = lb_obj;
        end
        
        % clear all marks
        marked_list = marked_list & false;
        
        radii_check_list = [];
        
        % proceed to the next iteration
        iter = iter + 1;
        continue;
    end
    
    % the polytope is non-empty
    wvec = weightcollapse(w, repl, weight_fixed, has_spread);
    radii(newcons_prev_iter) = rad; %#ok<AGROW>
    newcons_prev_iter = [];
    
    if has_spread
        w_m = weightmodify(w);
    else
        w_m = w;
    end
    
    param = port2cpwl(port, wvec);
    [cparam, A, b] = cpwl2concmin(param);
    
    [model, params] = concmin2gurobi(cparam, A, b, 100, true);
    params.MIPFocus = 3;
    params.MIPGap = options.milp_gap;
    params.MIPGapAbs = options.tol * 0.5;
    params.BestBdStop = 1e-6;
    
    if options.display
        params.OutputFlag = 1;
    else
        params.OutputFlag = 0;
    end
    
    g_output = gurobi(model, params);
    milp_count = milp_count + 1;
    
    is_feas = strcmp(g_output.status, 'USER_OBJ_LIMIT') ...
        || g_output.objval >= 0;
    LB = g_output.objbound;
    
    if strcmp(g_output.status, 'NODE_LIMIT') ...
            || strcmp(g_output.status, 'TIME_LIMIT')
        if g_output.objval >= 0 && g_output.objbound < 0
            temp_obj = price_bounds' * w_m - LB;
            if temp_obj > rprice_ub
                LB = min(price_bounds' * w_m ...
                    - 0.5 * (rprice_ub + rprice_cut), 0);
            end
        end
    end
    
    % introduce an objective cut whenever possible
    cur_obj = price_bounds' * w_m - LB;
    if cur_obj < rprice_ub
        weight_opt = wvec;
        weight_opt(1) = weight_opt(1) - LB;
        rprice_ub = cur_obj;
        radii_check_list = [];
    end
    
    if is_feas
        % the current center point is feasible
        state_switch = false;
        
        % clear all marks
        marked_list = marked_list & false;
        
        % proceed to the next iteration
        iter = iter + 1;
        continue;
    end
    
    % the current center point is infeasible, introduce feasibility
    % cut(s)
    if isfield(g_output, 'pool')
        x_feas = horzcat(g_output.pool.xn);
        x_feas = x_feas(1:n, [g_output.pool.objval] < 0);
    else
        x_feas = g_output.x(1:n);
    end
    cons_C_x = portpointcons(port, max(0, x_feas));
    [newcons_C_x, newb_x] = replportcons(cons_C_x, repl, weight_fixed, ...
        has_spread);
    
    newcons_num = size(x_feas, 2);
    A_feas = [A_feas; -newcons_C_x]; %#ok<AGROW>
    b_feas = [b_feas; newb_x]; %#ok<AGROW>
    x_agg = [x_agg, x_feas]; %#ok<AGROW>
    active_list = [active_list; true(newcons_num, 1)]; %#ok<AGROW>
    marked_list = [marked_list; false(newcons_num, 1)]; %#ok<AGROW>
    newcons_prev_iter = length(radii) + (1:newcons_num);
    radii = [radii; inf(newcons_num, 1)]; %#ok<AGROW>
    
    if ~state_switch
        % the state switch is off
        state_switch = true;
    else
        % the state switch is on
        state_switch = false;
        marked_list(end - newcons_num + 1:end) = true;
        
        % proceed to the next iteration
        iter = iter + 1;
        continue;
    end
    
    % delete constraints
    delete_list = rad <= options.radius_factor * radii & ~marked_list ...
        & cpwleval(x_agg, param)' > sqrt(sum(A_feas .^ 2, 2)) ...
        * rad + 1e-2;
    delete_list(end - newcons_num + 1:end) = false;
    active_list = active_list & ~delete_list;
    
    % proceed to the next iteration
    iter = iter + 1;
end

% prepare output
output = struct('iter', iter, 'lp_count', lp_count, ...
    'milp_count', milp_count, 'x', x_agg(:, active_list), ...
    'x_hist', x_agg, 'x_opt', x_opt, 'measure_opt', measure_opt, ...
    'dual_opt', dual_opt);

end