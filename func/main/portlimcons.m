function [cons_C, cons_D, lp_count] = portlimcons(portlim)
% Generate constraints on the portfolio weights such that the continuous
% piecewise linear function is bounded from below in the entire positive
% quadrant
% Input:
%       portlim: limit of portfolio, generated by portcreate
% Outputs:
%       cons_C: sparse matrix representing the constraints related to the
%           weights
%       cons_D: sparse matrix representing the constraints related to
%           auxiliary variables
%       lp_count: number of LP solved

aff_C = portlim.aff.C;

% prepare the half-plane part
hp_num = 0;
if isfield(portlim, 'hp')
    hp_num = size(portlim.hp.A, 1);
    hp_d = cell(hp_num, 1);
    hp_C = cell(hp_num, 1);
    
    for i = 1:hp_num
        hp_d{i} = portlim.hp.A(i, :);
        hp_C{i} = portlim.hp.C(i, :) .* portlim.hp.A(i, :)';
    end
end

% prepare the general part
gen_count = zeros(0, 1);
if isfield(portlim, 'gen')
    gen_num = max(portlim.gen.grp);
    gen_d = cell(gen_num, 1);
    gen_C = cell(gen_num, 1);
    gen_count = zeros(gen_num, 1);
    
    for i = 1:gen_num
        cur_list = portlim.gen.grp == i;
        cur_A = portlim.gen.A(cur_list, :);
        cur_C = portlim.gen.C(i, :);
        cur_row_num = size(cur_A, 1);
        gen_count(i) = cur_row_num;
        
        gen_d{i} = cell(cur_row_num, 1);
        gen_C{i} = cell(cur_row_num, 1);
        
        for j = 1:cur_row_num
            logi_j = true(cur_row_num, 1);
            logi_j(j) = false;
            gen_d{i}{j} = cur_A(j, :) - cur_A(logi_j, :);
            gen_C{i}{j} = cur_C .* cur_A(j, :)';
        end
    end
end

% aggregate constraints for all cases
counter_max = [2 * ones(hp_num, 1); gen_count];
counter_num = length(counter_max);
counter = ones(counter_num, 1);
total_num = prod(counter_max);

if isempty(counter_max)
    cons_C = aff_C;
    cons_D = [];
    return;
end

if total_num > 1e5
    error('problem size is too large');
end

cons_C_cell = cell(total_num, 1);
cons_D_cell = cell(total_num, 1);
next_index = 1;
lp_count = 0;

while true
    cur_C = aff_C;
    D_cell = cell(counter_num, 1);
    for q = 1:counter_num
        if q <= hp_num
            if counter(q) == 1
                D_cell{q} = -hp_d{q};
            else
                D_cell{q} = hp_d{q};
                cur_C = cur_C + hp_C{q};
            end
        else
            q_gen = q - hp_num;
            D_cell{q} = gen_d{q_gen}{counter(q)};
            cur_C = cur_C + gen_C{q_gen}{counter(q)};
        end
    end
    
    % update the counter
    counter(1) = counter(1) + 1;
    for q = 1:counter_num
        if counter(q) <= counter_max(q)
            break;
        end
        counter(q) = 1;
        counter(q + 1) = counter(q + 1) + 1;
    end
    
    % generate the set of vectors defining the cone
    cur_D = vertcat(D_cell{:})';
    % normalize the vectors such that the L-infinity norm is 1
    cur_D = cur_D ./ max(abs(cur_D), 1);
    col_num = size(cur_D, 2);
    
    % simplify the set of vectors and check whether the dual cone has empty
    % interior
    empty_int = false;
    next_col_index = 1;
    new_D = zeros(portlim.n, col_num);
    
    for i = 1:col_num
        dup = false;
        cur_col = cur_D(:, i);
        for j = 1:next_col_index - 1
            if all(cur_col == new_D(:, j))
                dup = true;
                break;
            end
            
            % if both v and -v are in the set, then the dual cone has empty
            % interior
            if all(cur_col + new_D(:, j) == 0)
                dup = true;
                empty_int = true;
                break;
            end
        end
        
        if empty_int
            % if the dual cone has been found to have empty interior, there
            % is no need to check the remaining vectors
            break;
        end
        
        if ~dup
            % otherwise, add this vector to the set
            new_D(:, next_col_index) = cur_col;
            next_col_index = next_col_index + 1;
        end
    end
    
    if empty_int
        % if the dual cone has been determined to have empty interior,
        % there is no need to run the LP
        if all(counter == counter_max)
            break;
        end
        continue;
    end
    
    new_D = new_D(:, 1:next_col_index - 1);
    
    % run LP to determine if the dual cone has empty interior
    lp_A = sparse(new_D);
    lp_b = sparse(portlim.n, 1);
    lp_lb = zeros(size(new_D, 2), 1);
    lp_f = sparse(size(new_D, 2), 1);
    lp_Aeq = ones(1, size(new_D, 2));
    lp_beq = 1;
    lp_opt = optimoptions('linprog', 'Display', 'off');
    [~, ~, exitflag] = linprog(lp_f, lp_A, lp_b, lp_Aeq, lp_beq, lp_lb, ...
        [], lp_opt);
    lp_count = lp_count + 1;
    
    if exitflag < 0
        % the dual cone has empty interior, aggregate the constraints
        cons_C_cell{next_index} = sparse(cur_C);
        cons_D_cell{next_index} = sparse(new_D);
        
        next_index = next_index + 1;
    end
    
    if all(counter == counter_max)
        break;
    end
end

cons_C = vertcat(cons_C_cell{1:next_index - 1});
cons_D = blkdiag(cons_D_cell{1:next_index - 1});

% round-off very small entries to improve the numerical condition of
% subsequent LP problems
cons_C = round(cons_C, 4);
cons_D = round(cons_D, 4);

end

